记录一些c++琐碎的知识点

## 内存管理

内存管理是c/c++非常重要的部分，因为它给c/c++带来了高性能与高自由度的好处，同时也引入了内存泄漏的弊端。

### 内存分配方式

| 内存区域                               | 说明                                                                                    | 举例                             |
| -------------------------------------- | --------------------------------------------------------------------------------------- | -------------------------------- |
| 栈                                     | 编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区                            | 局部变量、函数参数、函数返回值等 |
| 堆                                     | 一般都是由程序员分配释放，人工不释放结束时由系统回收                                    | new delete                       |
| 静态/全局 存储区（.bss 段和 .data 段） | 全局变量和静态变量保存的区域                                                            | static                           |
| 常量存储区（.data 段）                 | 运行期间不能改变的量，例如：100，字符串常量等                                           | const                            |
| 代码区（.text 段                       | 存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里                          |                                  |
| 自由存储区                             | new所申请的内存区域在C++中称为自由存储区,这是一个抽象的概念，不是具体的内存上的形式分区 | new malloc                       |

从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env
自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
堆与自由存储区还是有区别的，它们并非等价。

### 内存对齐

## 类型转换

常见的类型转换（C-style）如下

```c
int a = 10;
int b = 3;
double result = (double)a / (double)b;
```

这种风格的转换在c++中不是一个良好的使用习惯
c++的类型转换新增四个关键字，这四个关键字都是用于强制类型转换的
C++中风格是static_cast `<type>`(content)。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的
static_cast、const_cast、reinterpret_cast和dynamic_cast

### static_cast

```c++
int a = 10;
int b = 3;
double result = static_cast<double>(a) / static_cast<double>(b);
```

用法：static_cast <类型说明符> （变量或表达式)
它主要有如下几种用法
    （1）用于类层次结构中基类和派生类之间指针或引用的转换
    进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
    进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
    （2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
    （3）把空指针转换成目标类型的空指针
    （4）把任何类型的表达式转换为void类型
    注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。
如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换,不一定包含虚函数.

### const_cast

在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。
而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象 必须为指针或引用.
用法：const_cast<type_id> (expression)
    该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
    常量指针被转化成非常量指针，并且仍然指向原来的对象；
    常量引用被转换成非常量引用，并且仍然指向原来的对象；
    常量对象被转换成非常量对象。

### reinterpret_cast

在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型.
在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

### dynamic_cast

> （1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
> （2）不能用于内置的基本数据类型的强制转换。
> （3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
> （4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。
> **需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。**
> （5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
> 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。
> 向下转换的成功与否还与将要转换的类
> 型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
> 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。

## 初始化

c++11中广泛应用了花括号 `{}`的初始化形式
例如

```c++
int a = 10;
int a = {10};
int a {10};
int a(10);
```

在涉及类型转换时，花括号的形式会在编译阶段提示信息丢失的危险，并返回错误
例如

```c++11
long double ld = 3.1415926536;
int a {ld},b = {ld}; //错误
int a = ld;//正确，会隐式类型转换，确实丢失了精度
```

## 声明与定义

声明规定了变量的类型与命名，定义除此之外还申请了存储空间，也会赋一个初始值
增加关键字 `extern`且不显式初始化变量，如果包含了初始值就不再是声明而是定义了

```c++
extern int i; //声明
int j; //声明并定义
extern double i = 3.1416;//定义
```

## 引用与解引用(取地址，指针)

c++11中新增了**右值引用**，本节这里说的引用是**左值引用**
主要涉及的为 `&`,`*`两个符号
**`&`**

> 引用符号与取地址符号，取决于实际应用的时候
> 同样**`*`**
> 解引用符号与指针符号，取决于实际应用的时候

```c++
int i = 42;
int &r = i;//左值引用，也可以叫别名
int *p;//声明指针
/*
注意这里的理解是（int*） p, 声明一个整型的指针，
而不是 *p， 对于*p的理解就是p指针指向的对象,
但是书写上一般都是int *p,这是为了避免类似
int* p,a;的误解，这里的p是指针而a不是，所以*p一般连续书写
*/
p = &i;//这里就是取地址符号了，将i的地址赋给p指针
*p = i;//这里是解引用，即指针p所指向的对象
int &r2 = *p;//引用与解引用
```

进一步理解*与&
`int a, *p=&a, &r=a;`
在上面这个定义过程中，包括了(base type)基本数据类型即这里的 `int`,声明符 `*`和 `&`

## 空指针

c++11 引入了 `nullptr`这一特殊类型，它可以被转换为任何其他的指针类型
空指针有三种方式生成

```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```

其中第三种方式是需要 `#include<cstdlib>`, 这是因为NULL是一个宏定义，在cstdlib中定义为0

## 多态

### 编译期（静态

实现的方式主要通过模板与函数重载

### 运行期 （动态

类的继承派生（虚函数
运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现

### 运行期多态与编译期多态优缺点分析

**运行期多态优点**
OO设计中重要的特性，对客观世界直觉认识。
能够处理同一个继承体系下的异质类集合。
**运行期多态缺点**
运行期间进行虚函数绑定，提高了程序运行开销。
庞大的类继承层次，对接口的修改易影响类继承层次。
由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当值得付出的资源消耗，列为缺点有点勉强。
**编译期多态优点**
它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
在编译器完成多态，提高运行期效率。
具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
**编译期多态缺点**
程序可读性降低，代码调试带来困难。
无法实现模板的分离编译，当工程很大时，编译时间不可小觑。
无法处理异质对象集合。

## 内联函数(inline)

1. 内联函数是一种为了减小函数调用机制开销的设计

> 函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码

为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符

> 如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。
> 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数

2. 正如设计出发点所阐述的那样，是用来解决“小函数”调用的，如果函数体本身复杂，则不适合

> inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）

3. inline 关键字是面向定义而非声明的

> 这一点很重要，我们要理解 声明与定义的区别

结合类而言，内联函数有哪些呢

- 在类内部实现了函数（且函数不复杂），那么其实这个函数就是一个隐式的内联函数
- 类的声明没有加上 `inline`, 在类外的定义函数体前加上 `inline`
- inline 是一种"用于实现的关键字"，而不是一种"用于声明的关键字"。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联
- 类内部的声明没有加上 `inline`,外部定义也没有加上 `inline`,那么就不会被认为是内联函数

4. inline只是一种建议
   上述第一点中提到，这是一个编译期间放置替换的操作，实际上 `inline`函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
5. 慎用 `inline`
   内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。
   如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间（空间换时间）

> 以下情况不宜使用内联：
> （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
> （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）
