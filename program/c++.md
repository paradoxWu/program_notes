# 记录一些c++琐碎的知识点

## 内存管理
内存管理是c/c++非常重要的部分，因为它给c/c++带来了高性能与高自由度的好处，同时也引入了内存泄漏的弊端。
### 内存分配方式
|内存区域|说明|举例|
|--|--|--|
|栈|编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区|局部变量、函数参数、函数返回值等|
|堆|一般都是由程序员分配释放，人工不释放结束时由系统回收|new delete|
|静态/全局 存储区（.bss 段和 .data 段）|全局变量和静态变量保存的区域|static|
|常量存储区（.data 段）|运行期间不能改变的量，例如：100，字符串常量等|const|
|代码区（.text 段|存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里||
|自由存储区|new所申请的内存区域在C++中称为自由存储区,这是一个抽象的概念，不是具体的内存上的形式分区|new malloc|

从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env   
自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
堆与自由存储区还是有区别的，它们并非等价。 
### 内存对齐


## 类型转换

常见的类型转换（C-style）如下

```c
int a = 10;
int b = 3;
double result = (double)a / (double)b;
```

这种风格的转换在c++中不是一个良好的使用习惯
c++的类型转换新增四个关键字，这四个关键字都是用于强制类型转换的
C++中风格是static_cast`<type>`(content)。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的
static_cast、const_cast、reinterpret_cast和dynamic_cast

### static_cast

```c++
int a = 10;
int b = 3;
double result = static_cast<double>(a) / static_cast<double>(b);
```

用法：static_cast <类型说明符> （变量或表达式)
它主要有如下几种用法
    （1）用于类层次结构中基类和派生类之间指针或引用的转换
    进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
    进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
    （2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
    （3）把空指针转换成目标类型的空指针
    （4）把任何类型的表达式转换为void类型
    注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。
如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换,不一定包含虚函数.

### const_cast

在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。
而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象 必须为指针或引用.
用法：const_cast<type_id> (expression)
    该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
    常量指针被转化成非常量指针，并且仍然指向原来的对象；
    常量引用被转换成非常量引用，并且仍然指向原来的对象；
    常量对象被转换成非常量对象。

### reinterpret_cast

在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型.
在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

### dynamic_cast

> （1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
> （2）不能用于内置的基本数据类型的强制转换。
> （3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
> （4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。
> **需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。**
> （5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
> 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。
> 向下转换的成功与否还与将要转换的类
> 型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
> 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。

## 初始化

c++11中广泛应用了花括号 `{}`的初始化形式
例如

```c++
int a = 10;
int a = {10};
int a {10};
int a(10);
```

在涉及类型转换时，花括号的形式会在编译阶段提示信息丢失的危险，并返回错误
例如

```c++11
long double ld = 3.1415926536;
int a {ld},b = {ld}; //错误
int a = ld;//正确，会隐式类型转换，确实丢失了精度
```

## 声明与定义

声明规定了变量的类型与命名，定义除此之外还申请了存储空间，也会赋一个初始值
增加关键字 `extern`且不显式初始化变量，如果包含了初始值就不再是声明而是定义了

```c++
extern int i; //声明
int j; //声明并定义
extern double i = 3.1416;//定义
```

## 引用与解引用(取地址，指针)

c++11中新增了**右值引用**，本节这里说的引用是**左值引用**
主要涉及的为 `&`,`*`两个符号
**`&`**

> 引用符号与取地址符号，取决于实际应用的时候
> 同样**`*`**
> 解引用符号与指针符号，取决于实际应用的时候

```c++
int i = 42;
int &r = i;//左值引用，也可以叫别名
int *p;//声明指针
/*
注意这里的理解是（int*） p, 声明一个整型的指针，
而不是 *p， 对于*p的理解就是p指针指向的对象,
但是书写上一般都是int *p,这是为了避免类似
int* p,a;的误解，这里的p是指针而a不是，所以*p一般连续书写
*/
p = &i;//这里就是取地址符号了，将i的地址赋给p指针
*p = i;//这里是解引用，即指针p所指向的对象
int &r2 = *p;//引用与解引用
```
进一步理解*与&  
`int a, *p=&a, &r=a;`
在上面这个定义过程中，包括了(base type)基本数据类型即这里的`int`,声明符`*`和`&`
## 空指针
c++11 引入了`nullptr`这一特殊类型，它可以被转换为任何其他的指针类型
空指针有三种方式生成
```c++
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
其中第三种方式是需要`#include<cstdlib>`, 这是因为NULL是一个宏定义，在cstdlib中定义为0
## 多态
### 编译期（静态
实现的方式主要通过模板与函数重载
### 运行期 （动态
类的继承派生（虚函数  
运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现  
### 运行期多态与编译期多态优缺点分析
**运行期多态优点**  
OO设计中重要的特性，对客观世界直觉认识。
能够处理同一个继承体系下的异质类集合。
**运行期多态缺点**  
运行期间进行虚函数绑定，提高了程序运行开销。
庞大的类继承层次，对接口的修改易影响类继承层次。
由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当值得付出的资源消耗，列为缺点有点勉强。
**编译期多态优点**  
它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
在编译器完成多态，提高运行期效率。
具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
**编译期多态缺点**  
程序可读性降低，代码调试带来困难。
无法实现模板的分离编译，当工程很大时，编译时间不可小觑。
无法处理异质对象集合。
